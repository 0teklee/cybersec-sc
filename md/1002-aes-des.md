# AES/DES 대칭 키 암호화 알고리즘

## 개요

이번 강의에서는 암호화 알고리즘에 대해 간략히 알아보았습니다.  
`AES`/`DES`의 대칭키 알고리즘 원리를 살피고,  
다음 글에서 비대칭 키, `RSA`, **해시 함수**에 대한 내용을 이어 작성하겠습니다.

---

## 대칭키

> `Symmetric key encryption`
> **암호화와 복호화에 같은 키**를 사용하는 암호 방식

반대 개념은 **비대칭 열쇠 암호**, 공개 열쇠 암호 (public-key cryptography)입니다.  
`JWT`(`JSON Web Token`)의 공개키, 비밀키 방식을 떠올리면 쉽습니다.  

#### 대칭키 주요 특성

- 암복호화 **속도가 빠르지만 상대방도 같은 열쇠를 가지고 있어야 함**
  - 잠긴 문을 열쇠가 하나라고 이해했습니다.
- 열쇠 **전달 과정**에서 열쇠 **정보가 노출될 수 있는 가능성**이 있음
  - 단 하나의 열쇠를 누군가 탈취할 수 있겠습니다.
- 대표적인 대칭키로 `AES`/`DES`가 있습니다.

---

## `AES`/`DES`

- AES와 DES

|                   | DES        | AES                          |
|-------------------|------------|------------------------------|
| 페이스텔            | 페이스텔   | 비페이스텔                   |
| 블록크기          | 64bits     | 128bits                      |
| 키길이            | 56bits     | 128/192/256bits              |
| 암호화 프리미티브 | 치환, 전치 | 치환, 쉬프트, 비트혼합(분산) |

### 용어

강의에서 낯선 용어가 많아 정리해보았습니다:

- 페이스텔 (`Feistel`)
  - 페이스텔은 다음 암호화 과정을 따릅니다:
    1. 입력 데이터를 두 부분으로 나누고,
    2. 한쪽을 함수 처리 후
    3. 다른쪽과 `XOR` 연산으로 결합하는 구조
  - **복호화 시 동일한 구조로 역연산이 가능**해 효율적
  - 암호화할 데이터 전체/부분 변환 여부에 따른 구분으로 파악했습니다.
- 비페이스텔 (`Non-Feistel`)
  - **입력 블록 전체를 한 번에 변환**하는 구조
  - `AES`처럼 순차적인 *치환*(`Substitution`)과 *변환*(`Transformation`) 사용
- **암호화 프리미티브** (Encryption Primitive)
  - **암호 알고리즘을 구성하는 기본 연산 요소**.
  - 예: 치환, 전치, 쉬프트, 비트 혼합 등.
- 블록 크기 (Block Size)
  - 암호화 시 한 번에 처리되는 데이터의 크기.
  - `DES`는 64비트, `AES`는 128비트 암기하겠습니다.
- 키 길이 (Key Length)
  - 암호화에 사용되는 **비밀키의 비트 수**.
  - **길수록 보안성은 높지만 연산량도 증가**함.

### 암호화 연산 요소

위 용어들은 기본적으로 숙지해야 할 내용으로 보입니다.  
특히 **암호화 프리미티브**가 기본 연산이라니 중요해 보입니다.
주요 용어를 표로 정리했습니다:

| 용어                               | 설명                                                                                              |
|------------------------------------|---------------------------------------------------------------------------------------------------|
| **치환 (Substitution)**            | 데이터의 비트를 다른 비트로 바꾸는 연산으로, *혼돈(confusion)을 높여* 키와 평문의 관계를 숨김       |
| **전치 (Permutation)**             | **비트나 바이트의 위치를 재배열**하여 *분산(diffusion)*을 높이고 데이터 패턴을 섞음                     |
| **쉬프트 (Shift)**                 | **데이터 비트를 특정 방향으로 이동시키는 연산**으로, `AES`에서는 행 단위 이동(ShiftRows)에 사용         |
| **비트 혼합 (Mixing / Diffusion)** | 여러 비트를 조합해 새로운 값을 생성하며, 입력 비트 하나의 변화가 전체 출력에 영향을 미치도록 설계 |

---

## DES

> `Data Encryption Standard`

기술적인 원리 이해가 되지 않아 추가로 살펴보았습니다.  
[나무위키 문서](https://namu.wiki/w/DES)에 설명이 잘 되어있습니다.
차근차근 기본 원리 파악에 집중해 보겠습니다.

### 기본 원리

|                   |                                |
|-------------------|--------------------------------|
| 구조              | 페이스텔 Feistel 네트워크      |
| 블록 크기         | 64bits                         |
| 키 길이           | 56bits                         |
| 암호화 프리미티브 | 혼돈, 분산                     |

- 64비트 평문을 64비트 **암호문으로 암호화**하며 키의 길이는 `56bits`, **라운드 수는 16**
- *키의 크기는 64비트*, **7비트마다 오류검출을 위한 1비트씩 들어갔기 때문에 실질적인 키의 길이는 56비트**

이어지는 `DES` 주요 알고리즘 파악에 앞서 용어를 찾아보았습니다.

#### ❓ Round

한 번의 암호화를 여러 단계로 반복하는데, 각 단계를 **“라운드”**라고 부릅니다.

- `DES`는 **16라운드**를 수행합니다.
- 매 라운드마다 **부분 키(subkey)**를 사용해 **혼돈(confusion)**과 **분산(diffusion)** 효과를 강화합니다.
- 구조는 페이스텔(Feistel) 방식으로, 데이터를 `L(왼쪽)`과 `R(오른쪽)` 두 블록으로 나눕니다.
  
#### ❓ 암호문 Ciphertext

- 평문(plain text)을 **암호화한 결과 데이터**입니다.
  - 문자열 "plain text"의 각 알파벳 인덱스를 -1 씩 이동하면 암호문 `okzhm sdws`가 됩니다.
- `DES`에서는 64비트 평문이 **동일한 크기(64비트)의 암호문으로 변환**됩니다.
- 복호화(`decryption`)를 거치면 다시 원래 평문으로 되돌릴 수 있습니다.

### DES 원리

`DES` 원리 파악을 위해 주요 개념을 간략히 알아보겠습니다.

#### DES 암호화 과정 및 구조

`DES`의 암호화 과정을 단순화하면 다음과 같습니다:

```bash
64비트 평문 
→ 초기 전치(IP) 
→ 16라운드 반복 
  L0, R0 = 32비트씩 분할
  ↓
  for i = 1 to 16:
    Li = R(i-1)
    Ri = L(i-1) XOR F(R(i-1), Ki)
  ↓
  L16, R16을 결합
→ 최종 전치(IP⁻¹) 
→ 암호문 출력
```

조금 더 디테일하게 시각적 구조로 정리하면 아래와 같습니다:

```bash
             ┌──────────────────────────────┐
64bit 입력 → │ Initial Permutation (IP)     │
             └────────────┬─────────────────┘
                          │
             ┌────────────┴────────────┐
             │                         │
           L0(32bit)               R0(32bit)
             │                         │
             │<───┐                    │
             │    │16라운드 반복       │
             │    └─ R(i) = L(i-1) XOR F(R(i-1), Kᵢ)
             │
           R16(32bit)             L16(32bit)
             └────────────┬────────────┘
                          │
             ┌────────────┴────────────┐
             │ Final Permutation (IP⁻¹)│
             └────────────┬────────────┘
                          │
                       64bit 암호문
```

- 16개의 페이스탈 `Feistal` 라운드 함수가 사용됩니다.
- K1 ~ k16 -> round1 ~ round16
- `DES`는 **56비트 키길이를 가지기 때문에 전수조사에 취약**하다고 합니다.
  - 대안으로 이중 des, 삼중 des (triple des)를 사용합니다.

`DES`가 56비트 키 길이를 가지는 이유는

- 7 비트 + 1 오류 검출 비트 => 64비트로 구성
- 64 - 8 => 56비트가 실질적인 키 길이

#### P-BOX

> 2개의 전치 `Permutation`
  
- 비트 위치를 섞는 **전치 연산**(`permutation`)을 담당합니다.
- 데이터를 재배열함으로써 **분산(diffusion)**을 높입니다.
- 즉, 한 비트의 변화가 출력 전체에 영향을 주도록 설계된 장치입니다.

---

## AES

**`Advanced Encryption Standard`**

> `DES`는 56비트의 키를 사용하는 등의 문제로 안전하지 않다고 판단하여  
> **NIST**는 des를 대체할 새로운 암호 알고리즘 공모하였다고 합니다.  
> 따라서 고안된 것이 `AES`입니다.

### AES 특징

마찬가지로 `AES`의 특징을 표로 정리하면 다음과 같습니다.  
먼저 블록 크기, 키 길이, 비-파이스텔 구조가 `DES`와 차이점으로 파악됩니다.

|                        |                                                                     |
|------------------------|---------------------------------------------------------------------|
| 구조                   | 비페이스텔 구조 (Substitution–Permutation Network, SPN)             |
| 블록 크기              | 128bits  (고정)                                                     |
| 키 길이                | 128/192/256bits                                                     |
| 암호화 방식      | 혼돈(Confusion) + 분산(Diffusion)                                   |
| 암호화 프리미티브 연산 | 치환(Substitution), 행 이동(Shift), 열 혼합(Mix), 전치(Permutation) XOR |

### AES 원리

강의 시간에 배운 내용을 요약하면 다음과 같습니다.

- `AES`는 **라운드 반복 구조로 설계**
- 평문을 128비트(16바이트) **블록 단위로 쪼깨서 시작**
  - 블록 크기 **128비트** (16바이트) / 1바이트 = 8비트 **고정**
  - 키 길이: 128, 192, 256 ... aes-128, aes-192, aes-256
- AES-128 / 128비트 / 10라운드
- AES-192 / 192비트 / 12라운드
- AES-256 / 256비트 / 14라운드

#### AES 암호화 과정 및 구조

조금 더 상세히 `AES`의 암호화 과정을 살펴보면 다음과 같습니다:

```bash
128비트 평문 
→ 초기 키 추가 (AddRoundKey)
→ 10~14라운드 반복 (키 길이에 따라 다름)
  ↓
  for each round:
    1. SubBytes      (S-box 비선형 치환)
    2. ShiftRows     (행 단위 순환 이동)
    3. MixColumns    (열 단위 선형 변환)
    4. AddRoundKey   (라운드 키 XOR)
↓
최종 라운드 (MixColumns 생략)
→ 암호문 출력 (128비트)
```

이를 시각적으로 표현하면 다음과 같습니다:

```bash
              ┌──────────────────────────────┐
128bit 입력 →  │  AddRoundKey (초기 키 추가)     │
              └────────────┬─────────────────┘
                           │
             ┌─────────────┴─────────────┐
             │                           │
             | 라운드 반복 (10/12/14회)     │
             │                           │
             ├─► SubBytes (S-box 치환)
             ├─► ShiftRows (행 이동)
             ├─► MixColumns (열 혼합)
             └─► AddRoundKey (라운드 키 XOR)
                           │
              ┌────────────┴────────────┐
              │        최종 라운드         │
              │      (MixColumns 생략)   │
              └────────────┬────────────┘
                           │
                       128bit 암호문
```


- `AES`는 비페이스텔 구조(`SPN`) 기반으로, **블록 전체를 한 번에 변환합니다**.
  - 파이스텔 구조인 `DES`가 `L`, `R`로 평문을 나누는 것과 차이가 납니다.
- 각 라운드는 **동일한 연산 구조를 반복**하며, **키 길이에 따라 라운드 수가 다릅니다**.
  - 키 길이: 128 / 192 / 256bits
  - 라운드 수: 10 / 12 / 14
- 암호화 프리미티브는 **치환**(SubBytes)과 **혼합**(MixColumns)을 통한
  **혼돈(Confusion), 분산(Diffusion)** 효과에 기반합니다.

### AES 라운드 개요

앞서 살핀대로, `AES`의 라운드는 반복됩니다.  
각 라운드 반복문에 4가지 단계가 있어, 이를 간략히 정리합니다:

|   | 단계        | 연산                                                                                                       | 암호학적 역할   |
|---|:------------|------------------------------------------------------------------------------------------------------------|-----------------|
| 1 | SubBytes    | S-box를 사용한 비선형 바이트 치환. 암호문의 비선형성을 갖기 위해                                           | 혼돈(Confusion) |
| 2 | ShiftRows   | 각 행의 바이트를 좌측으로 순환 이동. 행 단위로 shift 연산                                                  | 분산(Diffusion) |
| 3 | MixColumns  | 각 열을 행렬 곱으로 혼합. 열에 속한 모든 바이트를 **순환 행렬**을 사용해 함수로 열에 있는 각 바이트를 대체 | 분산(Diffusion) |
| 4 | AddRoundKey | 라운드 키와 현재 state 블록을 비트별로 `xor` 연산                                                          | 키 결합         |

---

읽어주셔서 감사합니다!