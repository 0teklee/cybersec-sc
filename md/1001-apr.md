
# Automated Program Repair (APR)

**개요**

Automated Program Repair (APR)은 소스 코드의 결함을 자동으로 탐지하고, 수정 패치를 생성하며, 이를 검증해 **코드베이스에 병합하는 일련의 기술과 절차**입니다.
`APR`은 개발자의 디버깅 부담을 줄이고 소프트웨어 신뢰성을 향상시키는 것을 목표로 합니다.
`CI (Continuous Integration)`이 떠오르는 부분입니다. [링크](https://ko.wikipedia.org/wiki/%EC%A7%80%EC%86%8D%EC%A0%81_%ED%86%B5%ED%95%A9)
보안 뿐만 아니라, 일반적인 웹 제품에서 코드 테스트가 배포 과정에 포함되어 자동화 되어있습니다.
실무에서 `Git`과 함께 연동하여 사용하는 편이라, `CI/CD` 개념도 함께 살펴보면 좋습니다. 
이번 강의에선 조금 더 보안 + AI 관점에 대해 간략히 다루었습니다.

---

## APR 기본 파이프라인

1. **오류 탐지 (Error detection)**
   - 테스트 실패나 런타임 오류를 통해 결함을 발견합니다.

2. **오류 위치 식별 (Fault localization)**
   - 결함이 의심되는 코드 줄을 좁혀냅니다. 예: 조건문 분기, null 체크 등. 일반적으로 상위 5개 정도의 후보 라인을 추출합니다.

3. **패치 생성 (Patch generation)**
   - 각 후보 라인에 대해 여러 패치 후보를 자동 생성합니다. 예: 라인당 50개의 후보를 생성하는 식으로 탐색합니다.

4. **패치 검증 (Patch validation)**
   - 전체 테스트를 다시 실행해 패치가 통과하는지 확인합니다. 통과하는 후보를 "plausible patch"라 부릅니다.

5. **패치 선택 및 병합 (Patch selection & merge)**
   - 품질 점수(예: 테스트 커버리지, 패치 크기, 정적 분석 결과 등)를 비교해 최종 패치를 선택하고 코드베이스에 병합합니다.

---


### 사용자 입력 검증 템플릿 (파이썬)

테스트 케이스: 정상 케이스, 길이 초과 케이스, 특수문자 포함 케이스 등을 추가해 검증합니다.
예시)

```python
# before
username = request.form.get('username')

# after (apply template)
username_raw = request.form.get('username')
if username_raw is None:
    raise BadRequest("username required")
username = username_raw.strip()
if len(username) > 64:
    raise BadRequest("username too long")
if not re.match(r'^[A-Za-z0-9_-]+$', username):
    raise BadRequest("invalid username")
```


```bash
+-------------------+---------------------------------------------+
| 단계              | 설명                                          |
+-------------------+---------------------------------------------+
| 1. 오류 탐지       | 테스트 실패나 런타임 오류를 통해 결함 발견             |
| 2. 오류 위치 식별   | 결함 의심 라인(예: 조건문, null 체크) 후보 추출       |
| 3. 패치 생성       | 후보 라인별 자동 패치 후보 생성(예: 다수 후보)         |
| 4. 패치 검증       | 전체 테스트 실행으로 패치 유효성 검증                 |
| 5. 패치 선택       | 품질 점수로 최종 패치 선정 및 병합                   |
+-------------------+---------------------------------------------+
```



## LLM을 이용한 취약점 탐지 (Vulnerability Localization, VL)

- LLM 기반 접근법은 코드의 문맥을 이해해 취약한 위치를 찾아내는 데 활용됩니다.
- **문제점**:
  - 코드 줄 수(LoC)가 증가할수록 정확도가 떨어지는 경향이 있습니다.
  - **앞뒤 문맥은 잘 기억해도 중간 부분을 놓치는** "**lost-in-the-middle**" 현상이 발생할 수 있습니다.
   - 보안 뿐만 아니라 `LLM` 에이젼트를 사용하면서 자주 느끼는 문제입니다.
   - `LLM` 모델에 대해 잘 아시는 분들이 알려주시면 감사하겠습니다.
  - 주석이나 불필요한 코드가 노이즈가 되어 환각(`hallucination`)을 일으킬 수 있습니다.
  - 다양한 프로그래밍 언어와 패턴을 학습하기 위한 데이터가 부족할 수 있습니다.

---

## 보안 패치 생성 기법 (Security Patch Generation, SPG)

1. **템플릿 기반 (Template-based)**
   - 예: PAR 기법. 미리 정의한 코드 템플릿을 이용해 사용자 입력이 들어가는 부분을 안전하게 대체합니다.

2. **유전 알고리즘 기반 (Genetic algorithms)**
   - 예: GenProg. 패치를 개체로 보고 진화적 탐색을 통해 점점 더 나은 후보를 찾아냅니다. 무작위 탐색 대신 자연선택과 유사한 방식으로 최적화를 수행합니다.

3. **LLM 기반 (LLM-based, e.g., Codex)**
   - 코드 생성 능력을 가진 대형언어모델(예: Codex, GPT 계열)을 이용해 패치를 생성합니다. APR 도구와 결합해 더 정교한 수정을 시도할 수 있습니다.

---

## 추가 설명 및 한계

- APR은 많은 경우에 작은 코드 변경으로도 문제를 해결할 수 있지만, 모든 버그를 자동으로 정확히 고치지는 못합니다.
- 패치가 통과하는 것이 항상 올바른 수정을 의미하지 않으므로(일시적 회피 등), 추가적인 정적/동적 검증이 필요합니다.
- LLM 기반 접근은 빠르게 발전하고 있으나, 맥락 길이, 노이즈, 언어 다양성 등 현실적인 제약을 염두에 두어야 합니다.

---

---

# OCR 적용하여 텍스트 추출한 부분:

# Automated Program Repair

---



# APR

• 1.오류 탐지

• 2.오류 위치 식별

• 3.패치 생성

• 4.패치 검증

• 5.패치 선택

---



# APR

- 오류 탐지
- 테스트에서 실패한 케이스 발견
- 오류 위치 식별
- 결함 의심 라인 5개 추출 (예: 조건문 분기, null 체크 등)
- 패치 생성
- 각 라인에 대해 50개 패치 후보 자동 생성
- 패치 검증
- 모든 테스트를 다시 돌려서 2개만 성공 (plausible patch)
- 패치 선택
- 품질 점수를 비교해 1개를 최종 채택 → 코드베이스에 병합

-

---

# APR

- LLM을 이용한 취약점 탐지 (Vulnerability Localization, VL)
  - 코드 줄 수 (LoC)가 증가함에 따라 정확도가 떨어짐
  - 앞과 뒤 정보는 잘 기억하지만, 중간 부분의 내용을 놓치는 lost in the middle 현상 발생

![[2-APR_p4_img1.jpeg]]

---



APR

- LLM을 이용한 취약점 탐지 (Vulnerability Localization, VL)
- 주석 또는 불필요한 코드로 인한 노이즈 > 환각 발생
- 프로그래밍 언어 등 다양성으로 인한 학습 패턴 부족

#

---

# APR 

- 보안 패치 생성 (Security Patch Generation, SPG)
- 템플릿 기반(PAR)
- 유전 알고리즘(GenProg)
- LLM 기반(codex)
python
\# before
username = request.form.get('username')
\# after (apply template)
username_raw = request.form.get('username')
if username_raw is None:
raise BadRequest("username required")
username = username_raw.strip()
if len(username) > 64:
raise BadRequest("username too long")
if not re.match(r'^[A-Za-z0-9_-]+\$', username):
raise BadRequest("invalid username")
테스트: 정상 케이스, 길이 초과, 특수문자 포함 케이스 추가

---

# APR 

- 템플릿 기반
- 예) PAR
- 사용자 입력 들어가는 곳에 코드 템플릿 세팅
python
\# before
username = request.form.get('username')
\# after (apply template)
username_raw = request.form.get('username')
if username_raw is None:
raise BadRequest("username required")
username = username_raw.strip()
if len(username) > 64:
raise BadRequest("username too long")
if not re.match(r'^[A-Za-z0-9_-]+\$', username):
raise BadRequest("invalid username")
테스트: 정상 케이스, 길이 초과, 특수문자 포함 케이스 추가

---



# APR

- 유전 알고리즘 = Genetic Algorithm (GA)
- 버그 패치를 진화적 탐색 문제로 보고 후보 패치를 개체로 진화시켜 최적 패치를 찾는 방식
- 대표적인 예) GenProg
- 버그를 수정하는 코드를 무작정 찾는 대신, 자연선택처럼 점점 더 나은 패치 후보를 진화시켜 최종적으로 가장 올바른 패치를 찾음

#

---

# - 유전 알고리즘 = Genetic Algorithm (GA)

## 2. 유전 알고리즘 기반 APR 절차

|  단계 | 설명 | 핵심 역할  |
| --- | --- | --- |
|  1. 초기 개체군 생성 (Initialization) | 원본 프로그램에서 무작위 패치 후 보들을 생성 | 시작점 설정  |
|  2. 적합도 평가 (Fitness Evaluation) | 각 후보 패치를 테스트 케이스로 평 가 (성공률 기반 점수) | "누가 더 좋은 패치인가?" 판단  |
|  3. 선택 (Selection) | 적합도가 높은 후보를 부모로 선택 | 좋은 패치 유한  |
|  4. 교차 (Crossover) | 부모 후보들의 일부를 교환하여 새 로운 자식 후보 생성 | 새로운 탐색 공간 확보  |
|  5. 돌연변이 (Mutation) | 후보 일부를 무작위로 변경하여 다 양성 확보 | 로컬 옵티마 탈출  |
|  6. 반복 (Iteration) | 적합도가 높은 해가 나올 때까지 $2-5$ 반복 | 점진적으로 패치 개선  |
|  7. 종료 및 채택 (Termination) | 모든 테스트를 통과하는 패치 발견 시 종료 | 최종 패치 적용  |
