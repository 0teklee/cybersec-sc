# 해시, 비대칭키

지난 글에 이어 이번엔 비대칭 암호화와 연관 개념을 알아봅니다.
해시 (함수), `SHA`, 비대칭키, `RSA` 등을 다룹니다.
개인 블로그에 작성 예전 글과 읽었던 서적을 함께 읽고 정리했습니다.

## 해시

*(...) 어떤 데이터를 찾는다고 했을 때 쉽게 떠올려볼 수 있는 방법은 처음부터 끝까지 순차 탐색하는 방법입니다. (...) 이 방법을 개선하려면 찾아야 할 값이 어디에 있는지 알아낼 방법이 필요합니다. 즉, 어떠한 값이 저장되는 위치를 어떤 규칙으로 정할 수 있다면 굳이 탐색을 할 필요 없이 바로 데이터를 찾아낼 수 있을 겁니다. 이런 생각을 바탕으로 만든 자료구조가 **해시hash**입니다. 해시는 해시 함수 를 사용해서 변환한 값을 인덱스로 삼아 키와 값을 저장해서 빠른 **데이터 탐색을 제공하는 자료구조**입니다.*.

- [코딩 테스트 합격자 되기: 자바스크립트 편](https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000008410599), 223p

해시의 특징은 다음과 같습니다:

- 단방향이다. 값을 통해선 키를 찾을 수는 없다. 오로지 '키Key'를 해시 함수에 넣어야 값을 얻을 수 있다.
- 키를 인덱스로 활용하려면 적절한 변환 과정(=해시 함수)가 필요하다.
- 키 자체가 인덱스로 기능하여, `O(1)`로 값을 얻을 수 있다.

블로그에 업로드한 관련 글을 공유합니다. ([링크](https://blog.leetekwoo.com/blog/58))
위 글에서는 해시 함수의 종류, 구성, 충돌 문제 등을 아주 간략히 다룹니다.
복습하려고 다시 읽고 있는데, 생각보다 더욱 깊은 내용이라 어렵습니다.
추후 알고리즘에 대해 더 보강해야겠습니다.
모듈러 연산`%`이 조금 중요하게 사용된다는 점만 기억하고 넘어가겠습니다.


### 해시 함수

> 입력값(파일, 문자열, 코드 등)을 **고정 길이의 고유한 값(hash value)**으로 변환하는 함수.

해시를 만들기 위해서는 해시 함수가 필요합니다.
해시 함수의 목적은 *키를 인덱스로 활용하기 위함*입니다.
해시의 **단방향성**을 암호화에 이용하는 것으로 이해했습니다.

다시 강의 내용으로 돌아와서, 강의에선 다음 해시 함수를 학습했습니다.  
먼저 두 해시 함수의 개요는 다음과 같습니다:

- `MD5`: 32글자 고정된 길이가 출력 (128bits)
  - 해시 값이 같은 충돌Collision 문제가 있음
- `SHA`: MD5보다 느리지만 더 안전한 함수
  - SHA-1 / 160 bits
  - SHA-256 / 256 bits
  - SHA-512 / 512 bits

  표로 정리한 내용은 다음과 같습니다:

|           | MD5                                         | SHA(-1/2/3)                                      |
|-----------|---------------------------------------------|--------------------------------------------------|
| 종류      | 해시함수                                       | 해시함수                                         |
| I/O      | 임의 길이 입력 → 128비트 해시값 출력                | 임의 길이 입력 → 160 / 256 / 512비트 해시값 출력 |
| 암호 방식  | 둘 모두 해시만으로는 복호화가 불가능합니다.             |                                                  |
| 특징      | 빠르지만 충돌 취약                                | 더 안전하고 현대 표준                            |
| 용도      | 파일 무결성 검사, 비밀번호 해시 저장                 | 전자서명, 인증, 블록체인, 보안 토큰 (JWT) |


`MD5`/`SHA` 차이점에 대해 학습하다 보니, 대칭키 `AES`/`DES`의 알고리즘과 달리,
`MD5`/`SHA` 자체는 암호 프리미티브 같은 알고리즘으로 설명하기 어려웠습니다.
궁금해서 더 찾아봤는데, 해시 함수 자체가 암호화의 방식으로 분류되는 것은 아니며,  
해시를 *암호 알고리즘 일부로 활용*할 수 있다고 합니다. (ex: `RSA` + `SHA`)
이를 통해 `RSA` 같은 **비대칭키 알고리즘**과 함께 사용되는 것임을 알게 되었습니다.  
관련 내용은 아래 챕터에서 살펴보겠습니다.  

---

## 비대칭키

> 비대칭키 `Asymmetric Key Encryption`

`AES`/`DES`의 대칭키와 달리 **비대칭키는 복수의 키를 사용합니다**.
비대칭키의 주요 특성을 간략히 살펴보면 다음과 같습니다:

- 키 개수 : 2개 (공개키 + 비밀키)
  - 암호화와 복호화에 다른 키가 사용됩니다.
- 속도가 대칭키에 비해 상대적으로 느립니다.
- 보안성: 공개키는 노출되어도 안전합니다.
  - 비밀키는 노출되면 보안상의 문제가 될 수 있습니다.
- 사용처: 데이터 암호화, 인증서, 키 교환, 전자서명 등 다양한 곳에 사용됩니다.

비대칭키의 암/복호화에 사용되는 공개/비밀키의 특성은 다음과 같습니다:

- 공개키 (`Public Key`): **데이터 암호화**, **서명 검증**에 사용
  - 누구나 볼 수 있습니다.
- 비밀키 (`Private Key`): **데이터 복호화**, **서명 생성**에 사용
  - 오직 소유자만 알고 있습니다.

```bash
1. 키 생성 (공개키 e, n) / (비밀키 d, n) 생성
2. 암호화 C = M^e mod n (공개키로 암호화) 
  → 평문 M을 공개키로 암호화
3. 복호화 M = C^d mod n (비밀키로 복호화) 
  → 암호문 C를 비밀키로 복호화
```

기본적인 원리는 수학적으로 연결되어 있지만,  
공개키로 암호화한 데이터를 비밀키 없이는 복호화할 수 없는 성질을 이용합니다.  

---

## RSA

`RSA`는 대표적인 **비대칭키 암호화 알고리즘**입니다.
수학적 난제(소인수 분해)에 기반한 비대칭 암호-라고 합니다.
간략한 예시는 다음과 같습니다:

```bash
1️. 두 개의 큰 소수 p, q 선택
2️. n = p × q 계산  → 모듈러 기반
3️. 오일러 함수 φ(n) = (p−1)(q−1) 계산
4️. e (공개키) 선택 — φ(n)과 서로소인 수
5️. d (비밀키) 계산 — e × d ≡ 1 (mod φ(n)) 만족

결과:
공개키 = (e, n)
비밀키 = (d, n)
```

시간이 오래 걸리는 방식이기 때문에, `AES`와 함께 사용한다고 합니다.

---

## 무결성 보장 기법

Confidentiality | **Integrity** | Availability
기밀성               **무결성**       가용성

무결성 `Integrity`사이버 보안 첫 강의에서 배운 `CIA` 원칙이 떠올랐습니다.
무결성에 대해 복습하자면:

- 정보가 변경되지 않고 정확성과 신뢰성을 유지하는 것입니다.
  - 해커가 데이터를 위/변조 할 수 있기 때문

데이터 무결성을 보장하는 방법으로 다음 2가지를 배웠습니다,

- 해싱 (Hashing)
- 체크섬 (Checksum)

### 체크섬 (checksum)

> 체크섬(Checksum) 은 데이터 전송이나 저장 중 오류를 감지하기 위한 값

*Checksum은 데이터를 전송하거나 저장할 때, 데이터가 손상되었는지(무결성이 유지되었는지) 확인하기 위해 계산되는 **검증용 숫자값**입니다.*

쉽게 말하자면 “데이터가 깨졌는지” 확인하는 오류 검출용 값입니다.
앞서 `DES`의 오류 검출을 위한 `1bit`가 떠오르는 부분입니다.
`Github Actions` 등 `CI/CD` 환경에서 빌드 캐시 확인에서 사용한 경험도 생각납니다.  
이처럼 평소 자주 보던 내용이어서 추가로 알아보았습니다.

간략히 파악한 체크섬 원리는 다음과 같습니다:

- 보내는 쪽(Sender)
  - 전송할 데이터(예: 파일, 패킷 등)를 **일정한 규칙**으로 계산해서 체크섬 값을 구함. (%)
  - 원본 데이터와 함께 전송.
- 받는 쪽(Receiver)
  - 받은 데이터를 똑같은 방식으로 다시 계산해서 체크섬 값을 구함.
  - 두 값이 같으면 데이터가 손상되지 않음, 다르면 오류나 변조 발생으로 간주.

```bash
전송 데이터: [100, 200, 50]

100 + 200 + 50 = 350  
350 mod 256 = 94
→ 체크섬 값 = 94
```

체크섬 알고리즘으로 순환 중복 검사 `CRC`를 설명해주셨습니다.

- 데이터 전송/저장 중 오류를 검출하기 위해 원본 데이터에서 **계산한 작은 값**을 **함께 전송**하여 무결성을 확인하는 방식
- **TCP/IP 네트워크에서 활용**된다고 합니다.

`CRC` 원리가 잘 이해가 가지 않아서 `LLM`에 질문을 해가며 학습봤는데,
글이 길어질 것 같아 다른 글로 정리하도록 하겠습니다.

마지막으로 체크섬 알고리즘을 표로 정리하면 다음과 같습니다:
| 알고리즘                          | 특징                                    | 사용 예시                  |
|-----------------------------------|-----------------------------------------|----------------------------|
| **Parity Bit (패리티 비트)**      | 1비트 오류 검출용, 가장 단순            | 초기 통신, 저장장치        |
| **Checksum (단순 합산형)**        | 바이트 합산 후 모듈러 연산              | TCP, UDP 헤더              |
| **CRC (Cyclic Redundancy Check)** | 다항식 기반, 오류 검출률 높음           | 네트워크, 디스크, ZIP 파일 |
| **Hash (SHA256 등)**              | 충돌 방지 + 무결성 검증 (암호학적 수준) | 파일 배포, 보안 검증       |

